<link rel="stylesheet" type="text/css" href="static/docs.css">

<h1>GameAPP 1.0-RELEASE DOCUMENT</h1>
<p class='copyright'>Copyright © 2016 Tim Heusschen B.V.</p>
<h2>Abstract</h2>
The release notes for GameAPP 1.0-RELEASE contain a summary of the initial application, including a description of its architectural design, technical design and its contributors. This document is applicable to anyone who is interested in the inner workings for the GameAPP application, or for people looking to install the application on their own machine.

<hr>

<h2>1. Introduction</h2>
<p>This document contains the release notes for GameAPP 1.0-RELEASE. It describes all added features, technologies, architecture and contributors. GameAPP 1.0-RELEASE has been released under the GNU GENERAL PUBLIC LICENSE Version 3. These license details can be found at <a href='https://www.github.com/universiteit/GameApplication'>https://www.github.com/universiteit/GameApplication</a>
You are encouraged to read the release notes before installing GameAPP on your machine.
<div class='padded'>
    <h3>1.1 ABOUT</h3>
    <div class='padded'>
    <p>GameAPP offers a collection of web based goal oriented minigames with a global account system shared by all the minigames

    GameAPP is meant to run on a webserver. GameAPP supports any WSGI compatible web server such as Apache (with mod_wsgi or mod_python), NGINX (with ngx_http_uwsgi_module) or Microsoft ISS (with WFastCGI, isapi-wsgi or an ASP gateway)

    GameAPP has been built using number of different frameworks and is deployed through a Jenkins pipeline. More information about this can be read in the technical details part of the release document.</p></div>

    <h3>1.2 SHARED DASHBOARD</h3>
    <div class='padded'>
    <p>The index page of the GameAPP application consists of a dashboard with links to each minigame. It serves as the entry point for all visitors of the application. In addition to the mini games, the dashboard contains a table of all the high scores / progress of the registered accounts. Finally the dashboard also serves as a gateway to the login and account registration page.</p></div>

    <h3>1.3 AUTHENTICATION</h3>
    <div class='padded'>
    <p>An account is required to participate in minigames. These minigames all share the same account system. This authentication system handles all the registration and authentication. Each minigame has its own separate data store, but relates the data of the minigame back to the user ids in the shared account system. More information about this system can be found in the technical details part of this release document.</p></div>

    <h3>1.4 MINIGAMES</h3>
    <div class='padded'>
    <p>The GameAPP contains two primary minigames.</p>

    <p class='red'><b>OGameOfThrones:</b></p>
        <div class='padded'>
        A browser based, real time strategy, massively multiplayer online game. In this game players take on the role of one of the Houses in the HBO hit series Game of Thrones. They are assigned a starting town and through actions they must upgrade their buildings, manage resources and acquire armies to defend themselves or attack their foes. A town has multiple buildings, each serving a specific function such as increasing one’s income or defense. Upgrading such a building incurs a cooldown, where higher levels incur longer cooldowns. Using resources generated by the town, a player would buy armies that can be used to defend his or her own town from invaders or sent off to capture an opposing town.</p>

        <p>The goal of the game is simple, to destroy all your enemies and capture all the towns in existence. The game is played in monthly intervals, whereafter each month the game state is reset.</p>

        <p><i>Target audience: Everyone</i></p>
    </div>
    <p class='red'><b>Shiba-Chef:</b></p>
    <div class='padded'>
        <p>An interactive children game for identifying different types of vegetables, and the ways in which you can prepare them. In this game the player prepares a delicious meal for a hungry shiba inu (a Japanese breed of dog) known as Shiba-Chef. In front of our chef there is a table with different means for food preperation, such as a cutting board, a pot containing boiling water or a teppanyaki grill. On the bottom of the screen there is a fridge containing the icons for many different types of meat and vegetables.</p>

        <p>The application shows a recipe of the meal our Shiba-Chef would like to eat. Using pre-defined actions the goal of the player is to drag the correct ingredient to the correct method of preparation. If the player succeeds in preparing the entire meal, the Shiba-Chef will eat it with delight. The player is awarded points (dogecoins) for each meal they prepare successfully.</p>

        <p><i>Target audience: Children 7-10</i></p>
    </div>
    </div>
</div>

<h2>2. Obtaining and installing GameAPP</h2>
<div class='padded'>
    <p>Installation of the GameAPP software can be done by downloading the complete repository at <a href='http://www.github.com/universiteit/GameApplication'>github.com/universiteit/GameApplication.</a></p>

    <h3>2.1 DEPENDENCIES</h3>
    <div class='padded'>
    <p>GameAPP has several dependencies including Flask, Flask-BCrypt and Flask-SQLAlchemy. A complete list of all the dependencies is found in the requirements.txt file. You are advised to install the requirements with pip (pip install -r requirements.txt) inside a virtual environment.</p>
    </div>
    <h3>2.2 RUNNING LOCALLY</h3>
    <div class='padded'>
    <p>GameAPP can be run locally using werkzeug. Simply run the run.py and GameAPP will automatically start a local server at port 9000</p>
    </div>
    <h3>2.3 SERVER APPLICATION</h3>
    <div class='padded'>
    <p>For a server version of GameAPP you can use WSGI deployment with a WSGI compatible webserver. Consult your specific web server documentation on how to add a WSGI application.</p>
    </div>
    <h3>2.4 THROUGH JENKINS</h3>
    <div class='padded'>
    <p>The GameAPP application can be deployed through a Jenkins pipeline. Detailed instructions can be found in the ‘Integrating GameAPP with Jenkins pipeline' section.</p>
    </div>
</div>

<h2>3. Technical Specifications</h2>

<div class='padded'>
<p>The following segment contains all the different technical specifications of the application.</p>

    <h3>3.1 ARCHITECTURE OF THE APPLICATION</h3>
    <div class='padded'>
    <p>The GameAPP application consists of a collection of packages all working in tandem. Each minigame is written as a separate package. The authentication layer and dashboard are also separate packages. A single app package imports all the sub packages and functions as a collection exposing all the packages as a single app.</p>

    <p>This design approach has been chosen because it keeps separate all the responsibilities and allows for easy addition of new packages such as new minigames.</p>
    </div>
    <h3>3.2 LANGUAGES, FRAMEWORKS, LIBRARIES</h3>
    <div class='padded'>
    <p>The majority of GameAPP has been written in Python 3.5.2 with a few shell scripts added for good measure. In addition to plain python two frameworks have been used.</p>

    <p class='red'><b>FLASK v0.11.1 (<a href='http://flask.pocoo.org/'>link</a>)</b></p>
    <p>For URL marshaling GameAPP uses the Flask micro framework. Flask is a collection of many different modules. A few of the modules used are <a href='http://werkzeug.pocoo.org'>Werkzeug</a> a WSGI utility library. It handles http requests, responses and sessions sessions. Or <a href='http://jinja.pocoo.org'>Jinja2</a>, a templating engine.</p>

    <p>Each python package in the application is written as a separate Flask application. One ‘master’ flask package (appropriately called app) imports all these sub packages and sets them as blueprints. Blueprints are flasks way of dealing with multiple, self contained packages. More information about blueprints can be read <a href='http://flask.pocoo.org/docs/0.11/blueprints/'>here</a></p>

    <p class='red'><b>SQL-ALCHEMY v2.1 (<a href='http://www.sqlalchemy.org'>link</a>)</b></p>
    <p>SQL Alchemy is an ORM for Python. GameAPP uses SQLite as its primary data store. Each application uses the ORM to declare its models and persist them through the database. SQL-ALCHEMY works with the repository design pattern backed with a unit of work pattern and object mappers.</p>

    <p class='red'><b>NOSE v1.3.7 (<a href='http://nose.readthedocs.io/en/latest/'>link</a>)</b></p>
    <p>Nose is a test tools used to automatically gather and run python tests. Tests are written as classes by inheriting from the builtin unit test type in python. Nose gathers each test class and runs them in sequence. The results output into an xUNIT style xml document for further processing.</p>

    <p class='red'><b>FLASK-BCRYPT v0.7.1 (<a href='https://flask-bcrypt.readthedocs.io/en/latest/'>link</a>)</b></p>
    <p>BCrypt is used for hashing stored passwords in the database.</p>

    <p class='red'><b>CELERY v4.0 (<a href='http://docs.celeryproject.org/en/latest/index.html'>link</a>)</b></p>
    <p>Distributed task queue for running background processes in the Flask Application.</p>

    <p class='red'><b>PIXIJS v4.2.3 (<a href='http://www.pixijs.com'>link</a>)</b></p>
    <p>PixiJS is a 2D WebGL Renderer for Javascript. Primarily used in the Shiba Chef application, PixiJS is used to render the images, handle input / output, create particle effects etc.</p>
    </div>

    <h3>3.3 TESTING</h3>
    <div class='padded'>
    <p>Each package has its own set of unit tests. These tests are placed in a dedicated test folder inside the package. These tests are automatically detected by nose. The main ‘app’ also has its own set of unit tests. Each developer runs the unit tests locally for the application they are working on. The tests are also used inside the Jenkins pipeline. More information about the pipeline can be found inside the ‘Integrating GameAPP with Jenkins pipeline’ section.</p>

    <p>Besides unit tests the GameAPP uses <a href='https://www.pylint.org'>PyLint</a>, a module for checking stylistic errors by matching the source code to the <a href='https://www.python.org/dev/peps/pep-0008/'>PEP style guide</a>. It generates an XML of the result.</p>
    </div>

    <h3>3.4 DASHBOARD PACKAGE</h3>
    <div class='padded'>
    <p>The dashboard package functions as an index that shows the user all the different minigames. It’s accessed by simply visiting the site root url. Additionally it allows navigation to the login and registration section, more about this can be read in the Authentication chapter of the Technical specifications.</p>

    <p>The dashboard exposes an interface for minigames to register their service. This interface accepts a hyperlink to the minigame’s root url and a url to a ‘display’ image. The dashboard maintains a collection of all the registered minigames. When a request is made for the dashboard, it renders an HTML template with the minigame images tiled in a grid as hyperlinks.</p>
    </div>
    <h3>3.5 AUTHENTICATION PACKAGE</h3>
    <div class='padded'>
        <p>The authentication package consists of a few pages for handling login and registration, and for providing a general interface through which other packages can check login status and retrieve user information.</p>

        <p class='red'><b>MODELS</b></p>
        <p>User accounts are modelled with SqlAlchemy and contain an id, username and password.</p>

        <p class='red'><b>REGISTRATION & LOGIN</b></p>
        <p>The package contains two templates: registration and login (routed to ../auth/ and ../auth/login respectively). Both of these routes are registered in the standard <i>__init__.py</i> file that is part of every package. Each of the pages contains a form with fields for username and password. These are forms post to routes that handle the login or registration. More information about login can be read in the Password Security and Session Handling segments.</p>

        <p class='red'><b>PASSWORD SECURITY</b></p>
        <p>Passwords are stored as hashes using BCrypt. When a user creates an account, their given password is hashed with BCrypt and persisted to the database. Once a user attempts to log in, the password he or she supplies are hashed and checked against the stored hash for the given username. If they match, the user is given a session (read more about sessions below), if they do not match the user is given an error message.</p>

        <p class='red'><b>SESSION HANDLING & RESTRICTED PAGES</b></p>
        <p>Interfacing with the server varies from minigame to minigame, so the option is let open per developer to use either JSON Web Tokens (JWT) or Cookie sessions.</p>

        <p>When a post is done on the login route, and the authentication is successful, the server sets a session cookie and returns a JWT containing their credentials. The cookie contains a hash of their username, the JWT contains a hash with their credentials. If the developer chooses to use JWT, they must set it in their local storage and send it add it to the headers for each subsequent request.</p>

        <p>To make restricting pages easier GameAPP provides an ‘secure’ python decorator added on top of functions: <i>@secure()</i>. This decorator is defined in attributes.py.</p>

        <p>The developer chooses what type of authentication is permitted (cookie or JWT) and adds the decorator to the route they wish to secure. The decorator handles checking the credentials and does automatic redirects if the user does not have permissions / is not logged in.</p>
    </div>

    <h3>3.6 OGAMEOFTHRONES PACKAGE</h3>
    
        <p>OGameOfThrones (hereafter referred to as OGoT) consists of a series of linked html pages that supply the user with information about a part of the game’s state, and html forms to handle interactivity.</p>
    <div class='padded'>
        <p class='red'><b>MODELS</b></p>
        <p>OGoT uses SqlAlchemy models for its data persistence. OGoT defines three classes: attack, player & town. </p>

        <p><b>Attack class</b></p>
        <p>The attack class models an attack going from one town to another. It contains references to the origin and destination, unit amounts and arrival time.</p>

        <p><b>Player class</b></p>
        <p>Models a OGoT player. Is tied to and shares id with a GameAPP user account. Also contains the house this player controls, and references to all the towns in his or her possession.</p>

        <p><b>Town class</b></p>
        <p>Contains things such as the buildings and their upgrade levels, stations units, resources etc. contained in this town. Also has a reference to the owning player and a town name.</p>

        <p class='red'><b>VIEWS</b></p>
        <p>The html pages are rendered using the JINJA templating engine with SqlAlchemy models. One of JINJA’s features is template inheritance. OGoT uses a single ‘base’ template containing elements required on all pages, such as the navigation bar. Each ‘specific’ page (referred to as a view) inherits from the template and contains the actual content. OGoT contains the following views:</p>

        <p><b>Index view (../RTS/)</b></p>
        <p>Splash screen for the user. Contains links to subsequent town views, informs the user if he or she is not logged in, and allows the user to ‘join’ OGoT.</p>

        <p><b>Towns view (../RTS/towns)</b></p>
        <p>Displays a table of all the towns active in OGoT. As its model it accepts a collection of towns.</p>

        <p><b>House view (../RTS/house)</b></p>
        <p>A player specific view. Each player represents a house in OGoT. The house view displays all the towns currently in the player’s possession. As its model it accepts a player.</p>

        <p><b>Town view (../RTS/town/<town_id>)</b></p>
        <p>The largest page, the town view shows all information specific to a town. It contains a table for its units, buildings and resources. This view contains the forms for sending attacks, upgrading buildings or buying units. As its model it accepts a town.</p>
        </div>
        <p>Routing to the views is handled through Flask. Each page has a route attached to it (registered in the <i>views.py</i> file) handling things such as authentication and retrieving models.</p>

        <p class='red'><b>USER INTERACTIVITY</b></p>
        <p>User interactivity is done through forms. Each form contains a number of fields that are posted to the server on submit. OGoT has a series of flask routes registered for handling the posts (found in <i>posts.py</i>). These handle the authentication, verification of input and return a response based on the type of post. (such as success or failure)</p>

        <p class='red'><b>BACKGROUND PROCESSES</b></p>
        Each ‘game tick’ resources have to be added to the towns, cooldowns and counters have to be updated and battles have to be calculated. This is done through Celery. Each piece of functionality has been implemented as a Celery task. Because the background processes have to repeat for an indeterminate amount of time they are assigned to a worker that loops over them in set intervals.
    </div>
    <h3>3.7 SHIBA CHEF</h3>
    <div class='padded'>
         <p>Shiba Chef is a web based game made with PixiJs. The game consists of an index page which contains the canvas where all objects of the game are drawn, animate and interacted with by the user.</p>
    <div class='padded'>
        <p class='red'><b>MODELS</b></p>
        <p>Shiba Chef uses models in form of javascript files, whereby the models themselves inherit the attributes and functions of their superclass as a basic form of Object Oriented Programming. Shiba Chef has 3 kinds of game objects: Lifeless, Equipment and Food.</p>

        <p><b>Lifeless</b></p>
        <p>Lifeless game objects are the simplest objects in the game, their attributes are only defined once in the constructor and they don’t move. An example of a Lifeless objects is the Table object. The lifeless object’s primary purpose is displaying sprites on screen. None of the lifeless objects have user interaction and serve as background scenery or visual aids.</p>

        <p><b>Equipment</b></p>
        <p>Equipment objects are dynamic game objects which functions can manipulate Food objects. They can e.g. chop, boil or grill ingredients when they are placed above them  to prepare the ingredients for the recipe. Examples of Equipment objects are: the Grill object, the Chopping Board object and the Cooking Pot object.</p>

        <p><b>Food</b></p>
        <p>Food objects are dynamic game objects which represent ingredients to build a recipe with. Their attributes define if they can be grilled, boiled or cut. When Food objects are placed on the presenting plate in front of the chef, the game (or the chef) checks if the ingredient fits correctly in the recipe, based on their attributes and kind of food .</p>

        <p class='red'><b>VIEWS</b></p>
        <p>Shiba chef only has a single page, this page uses a game engine (Pixi.js) to render visual elements on the user's browser:</p>

        <p><b>Index view (../shiba_chef/)</b></p>
        <p>Our index view contains all the logic required to play the shiba chef game. The game is completely javascript based and loads all of it resources using this one view. This view uses Pixi.js to render game objects, because our one page has a lot of elements to it the view never changes. All functionality can be reached from this single view.</p>

                </div>
        <p>Routing to the views is handled through Flask. Since the application is simple server side it currently only has a single route and a static file server for the static javascript, html and css files.</p>

        <p class='red'><b>USER INTERACTIVITY</b></p>
        <p>Users can interact with shiba chef by clicking on the game elements displayed on screen. The user can click and drag food to specific game elements such as the cutting board, plate or the bin. The interactivity is achieved through javascript event handlers (mouse down & up). All user actions are processed client side using javascript, for example validation of recipes, or transforming game objects such as a uncooked burger into a cooked burger.</p>
    </div>
</div>
<h2>4. Integrating GameAPP with Jenkins pipeline</h2>
<div class='padded'>
    <p>GameAPP is primarily designed for automatic deployment to a WSGI compatible web server through a CI tool such as Jenkins or Travis CI. The developers / maintainers of GameAPP use a Jenkins pipeline for their deployment, the details of which are discussed here.</p>
    <h3>4.1 TECHNOLOGIES USED</h3>
    <div class='padded'>
        <p class='red'><b>UBUNTU SERVER v16.04 LTS (<a href='https://www.ubuntu.com/server'>link</a>)</b></p>
        <p>The main OS of the entire build server.</p>
        
        <p class='red'><b>JENKINS v2.19.4 LTS (<a href='http://jenkins.io/'>link</a>)</b></p>
        <p>Jenkins is an open source automation server. It allows for automatic building, testing and deployment of sofware. Jenkins is used as the tool of choice for deploying GameAPP.</p>

        <p class='red'><b>APACHE HTTPD v2.4.23 (<a href='https://httpd.apache.org'>link</a>)</b></p>
        <p>Apache HTTPD is a web server project by the Apache Foundation. Documentation about configuring Apache for Flask using WSGI can be found <a href='flask.pocoo.org/docs/latest/deploying'>here</a></p>
    </div>
    <h3>4.2 GITHUB SETUP</h3>
    <div class='padded'>
        <p>The main GitHub repository does not allow for direct push access by the contributors. Instead the project is forked by smaller subsets of developers working together based on a specific area. For example, the developers of OGameOfThrones have a fork specifically for their minigame. The same is true for dashboard, Shiba Chef and Authentication developers. Completed features are added to the main repository after testing by the developers through pull requests. Developers constantly keep their fork up to date with changes to the origin.</p>
    </div>
    <h3>4.3 SHARED JENKINS SETUP FOR MASTER</h3>
    <div class='padded'>
        <p>The continuous integration server uses a Jenkins pipeline with three phases. Building is done automatically through an API exposed by the Jenkins server. The <a href='https://www.github.com/universiteit/GameApplication'>main repository</a> is configured to automatically make calls to this API once a commit has been done on the master branch. This triggers the setup phase.</p>

        <p class='red'><b>SETUP PHASE</b></p>
        <p>The first step Jenkins takes is clearing the existing working directory. Next it clones the repository into the working directory. A python virtual environment is then created and activated, followed by an installation through pip of all the requirements listed in the requirements file located at the root of the repository. Once all dependencies have been installed Jenkins moves on to the testing phase.</p>

        <p class='red'><b>TESTING PHASE</b></p>
        <p>Jenkins runs nose on the root app without XML output options. This gathers all the test of the main package as well as all sub packages, sending the results to an xUnit compatible XML. These results are piped through to a report generator that visually details the test results. If any tests fail an email is sent out to the committer detailing the failure.</p>

        <p>After testing, Jenkins runs PyLint on the code and generates a code ‘cleanness’ report. Bad PyLint reports do not cause a failure of the pipeline.</p>

        <p class='red'><b>DEPLOYMENT PHASE</b></p>
        <p>Jenkins clears the /var/www directory, generates a new virtual environment and clones a fresh copy of the repository to the directory. Because Apache is configured for automatic reloading (as documented in the Flask WSGI documentation <a href='flask.pocoo.org/docs/latest/deploying'>here</a>) there is no need to reload apache manually.</p>
    </div>
    <h3>4.4 PERSONAL JENKINS SETUP FOR FORKS</h3>
    <div class='padded'>
        <p>Personal deployment pipelines are used by each development team working on a specific area of the application. The team has decided not to dictate how these pipelines are set up, and are up to the discretion of the individual team members. The only requirement is that the pipeline correctly gathers all the dependencies and runs the unit tests pertaining to their particular area (ex. Shiba Chef developers run the Shiba Chef unit tests).</p>
    </div>
</div>
<hr>
<h2>5. Contributors</h2>
<div class='padded'>
    <h3>Daniel Molenaar</h3>
    <div class='padded'>
        <p>Primary contributor to the authentication service, contributor to Shiba Chef and responsible for setting up the Jenkins pipeline.</p>
    </div>

    <h3>Bart Rijnders</h3>
    <div class='padded'>
        <p>Contributor to the authentication service, OGameOfThrones and primarily responsible for setting up the Jenkins pipeline and the release document.</p>
    </div>

    <h3>Thom Overhand</h3>
    <div class='padded'>
        <p>Primary contributor to OGameOfThrones.</p>
    </div>

    <h3>Jeffrey Maas</h3>
    <div class='padded'>
        <p>Primary contributor to OGameOfThrones.</p>
    </div>

    <h3>Stephen Goedhart</h3>
    <div class='padded'>
        <p>Primary contributor to the dashboard and contributor to Shiba Chef.</p>
    </div>

    <h3>Jorik Schouten</h3>
    <div class='padded'>
        <p>Primary contributor to Shiba Chef and memes. Also responsible for unit testing Shiba Chef.</p>
    </div>
</div>
<br>
<small style='text-align: center; display: block'>
    For questions or more information about GameAPP contact the developers at <a href='http://www.github.com/universiteit'>technische universiteit almere</a><br>

    Release document is modelled after those from the <a href='https://www.freebsd.org/releases/11.0R/relnotes.html'>FreeBSD project</a><br>

    These release notes are licensed under GPL 3.0<br>
    
</small>
<br>